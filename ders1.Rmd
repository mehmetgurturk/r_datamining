---
title: "Veri Tipi Belirleme"
author: "Mehmet Gurturk"
date: '2022-03-22'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Çalışacağımız verisetinin içeri aktarılması için `read.csv()` fonksiyonu kullanılır. 
İçeri aktaracağımız lokal dosya yolu ya da uzak sunucuda tutulan dosyanın yolu fonskiyonuna girdi olarak verilir.

```{r}
veriseti <- read.csv("Fin500.csv")
```

Veriseti yüklendikten sonra verisetinin içeriğini kontrol etmek üzere `head()` ve `tail()` fonsiyonları kullanılır.

```{r}
head(veriseti) 
tail(veriseti)
```

Verisetinin ilk ve son altı (6) satırını gördükten sonra versitesinin yapısına bakmak için `str()` fonksiyonunu ve verisetinin özetini görmek için ise `summary()` fonksiyonunu çalıştırdık.

```{r}
str(veriseti)
summary(veriseti)
```

Verisetimizin içerisindeki `veriseti$Industry`, `veriseti$Inception` ve `veriseti$City` verilerimizi `as.factor()` fonksiyonu ile kendi içlerinde gruplandırdık ve tekrar `<-` komutu ile verilirimizi kendi üzerlerine tekrar atadık.

```{r}
veriseti$Industry <- as.factor(veriseti$Industry)
veriseti$Inception <- as.factor(veriseti$Inception)
veriseti$City <- as.factor(veriseti$City)
```

Verisetimizin içerisinde bazı verilerimizin tipi, verilerin yazılışı uygun değildi. Verilerimizi uygun hale getirmek için öncelikle `gsub()` fonksiyonu ile verilerimizi temizledik. Daha sonra tekrar verilerimizi `<-` komutu ile atadık. Sadece `sub()` komutu ilk sıradaki veriyi değiştirir `gsub()` komutu ise başındaki 'g' yani 'global'den dolayı her argümana bakarak değişim gerçekleştirecek.

Daha sonra Verilerimizin türünü değiştirerek 'numeric' hale dönüştürebilmek için `as.numeric()` fonksiyonunu kullandık. Ve `<-` komutu ile verilirimizi tekrar atama işlemlerini gerçekleştirdik. İşlemleri ilk olarak `veriseti$Expenses` verimize uyguluyoruz.

```{r}
gsub(" Dollars", "", veriseti$Expenses)
gsub(",", "", veriseti$Expenses)
veriseti$Expenses <- as.numeric(veriseti$Expenses)
```

Daha sonra işlemleri `veriseti$Growth` verimize uyguluyoruz.

```{r}
gsub("%", "", veriseti$Growth)
veriseti$Growth <- as.numeric(veriseti$Growth)
```

Son verimizin içerisinde `$` işareti yer almaktadır. Bu işaret R dili için önem arz ettiğinden dolayı bu işareti kaldırırken yanında özel bir işaret daha kullanmamız gerekmektedir. Bunun için `\\$` şeklinde kullanacağız. Ayrıca verilerimizde kullandığımız fonksiyonları iç içe kullanabiliriz.

```{r}
gsub("\\$", "", veriseti$Revenue)
veriseti$Revenue <- as.numeric(gsub(",", "", veriseti$Revenue))
```

Missing Value değerleri ile uğraşacağımzıdan dolayı `library(Amelia)` paketini çağırdık.

```{r}
library(Amelia)
```

Verisetimizin missingness map'ini çizdirebilmek için `missmap()` komutunu uyguladık.

```{r}
missmap(veriseti)
```

Verisetimizin kaç satır ve kaç sütundan meydana geldiğini görebilmek için `dim()` komutunu uyguladık.

```{r}
dim(veriseti)
```

Verisetimizde istediğimiz satır ve sütunları `veriseti[]` komutu uyguluyoruz.

```{r}
veriseti[3,2] #3.satır 2.sütun
veriseti[3, ] #3.satırın tamamı
veriseti[ ,2] #2.satırın tamamı
```

Verisetimizin tam yani NA değer içerip içermediğini görebilmek için `complete.cases()` komutunu uyguluyoruz. Verisetimiz tam yani NA değer yoksa true, NA değer varsa false olarak geri dönüş vermektedir.

```{r}
complete.cases(veriseti)
```

Verisetimizdeki NA değerlerinin yer aldığı satırı göstermek için;

```{r}
veriseti[!complete.cases(veriseti), ] # ! ile incomplete olanları getirdik
```

Verisetimizde geliri 9 milyon olanları getirmek için;

```{r}
veriseti$Revenue == 9746272
```

Verisetimizde geliri 9 milyon olan satırı getirmek için;

```{r}
veriseti[veriseti$Revenue == 9746272, ]
```

True'ların yanında NA'lar dönüyor. Bundan kaçınmak için `which()` komutunu kullanıyoruz.

```{r}
which(veriseti$Revenue == 9746272)
```

Verisetimizde NA değeri olan satırları getirmek için;

```{r}
veriseti[is.na(veriseti$Expenses), ]
```

Verisetimizde çalışan sayısı 45 olan satırı getirmek için;

```{r}
veriseti[which(veriseti$Employees == 45), ]
```

verisetimizi yedeklemek için `<-` komutunu kullandık.

```{r}
backup <- veriseti
```

Verisetimizde complete olanlar ile tekrar veriseti oluşturmak için;

```{r}
veriseti <- veriseti[complete.cases(veriseti), ]
```

Verisetindeki satır numaralarını görmek için `row.names()` komutunu kullandık.

```{r}
row.names(veriseti)
```

Verisetimizde 1'den başlayarak tekrar satır numarası atamak için `1:nrow()` komutunu kullandık.

```{r}
veriseti <- 1:nrow(veriseti)
```

Kayıp verilerin değiştirilmesi için ilk olarak State sütununda NA olan değerleri çağırdık daha sonra da NA verileri değiştirdik.

```{r}
veriseti[!complete.cases(veriseti)]
veriseti[is.na(veriseti$State), ]
veriseti[is.na(veriseti$State) & veriseti$City == "New York", ]
veriseti[is.na(veriseti$State) & veriseti$City == "New York", "State"] <- "NY" #City sütunu New York olan ancak State sütununda NA olan yerlere NY ekledik

veriseti[is.na(veriseti$State) & veriseti$city == "San Francisco"]
veriseti[is.na(veriseti$State) & veriseti$City == "San Francisco", "State"] <- "CA"
```

Verisetimizde NA değeri olan sütunları tespit ettikten sonra "Employees" sütununda yer alan NA değerleri yerine aynı sütundaki meadian değerini atadık. "Employees" sütunu ile "Industry" sütunnda "Retail" olanları atadık. Daha sonra "Industry" sütununda "Fİnancial Services" olanları atadık.

```{r}
summary(veriseti$Employees)
veriseti[is.na(veriseti$Employees), ]

median(veriseti[, "Employees"]) # NA baskın olduğu için sonuç NA çıktı bundan kurultmak için aşağıdaki komutu girdik 
median(veriseti[, "Employees"], na.rm = T) #NA ya median değerini ata NA'yı dikkate alma
med_emp_ret <- median(veriseti[veriseti$Industry == "Retail", "Employees"], na.rm = T)

veriseti[is.na(veriseti$Employees) & veriseti$Industry == "Retail", ]
veriseti[is.na(veriseti$Employees) & veriseti$Industry == "Retail", "Employees"] <- med_emp_ret

med_emp_finservices <- median(veriseti[veriseti$Industry == "Financial Services", "Employees"], na.rm = T) 
veriseti[is.na(veriseti$Employees) & veriseti$Industry == "Financial Services", "Employees"] <- med_emp_finservices
```

"Expenses" kolununda NA olan değerleri "Revenue" kolunu "Profit" kolunu dolan verilerden çıkartarak elde ettik.

```{r}
summary(veriseti)
head(veriseti,25)

veriseti[is.na(veriseti$Expenses), ]
veriseti[is.na(veriseti$Expenses) & !is.na(veriseti$Revenue), ] #Revenue boş olmaması lazım
veriseti[is.na(veriseti$Expenses) & !is.na(veriseti$Revenue), "Expenses" ] #expenses kolonunu verecek

veriseti[is.na(veriseti$Expenses) & !is.na(veriseti$Revenue), "Expenses" ] <- veriseti[is.na(veriseti$Expenses) & !is.na(veriseti$Revenue), "Revenue" ] - veriseti[is.na(veriseti$Expenses) & !is.na(veriseti$Revenue), "Profit" ] 
```

"Revenue" kolununda NA olan değerleri kolunun ortalamasını NA olan değerlere atayarak elde ettik.

```{r}
summary(veriseti)
head(veriseti,25)

veriseti[is.na(veriseti$Revenue), ]
veriseti[is.na(veriseti$Revenue) & veriseti$Industry == "Construction", ] #Revenue NA olan Industry'ler Construction

mean(veriseti[, "Revenue"])
mean(veriseti[, "Revenue"], na.rm = T)
mea_rev <- mean(veriseti[, "Revenue"], na.rm = T)

veriseti[is.na(veriseti$Revenue) & veriseti$Industry == "Construction", "Revenue"] <- mea_rev
```

Matematiksel işlemler ile çalışacağımızdan dolayı `caret` paketini yükledik. Daha sonra R'da yerleşik veri kümesi olan `iris` veri kümesini çağırdık ve `iris` veri kümesinin yapısını ve özetini ortaya koyduk.

```{r}
library(caret)
data(iris)
str(iris)
summary(iris[,1:4]) #verisetindeki tüm satırlar ile 1. ve 4. sütunlar arasını aldık. Eğer 1. 3. ve 5. sütunları almak isteseydik C(1,3,5) komutunu uygulayacaktık.
```

Verisetimizde uygulayacağımız dönüşümler (matematiksel işlemler) için `preProcess` komutunu kullandık ve `preProcess` altındaki `scale` paketini çağırdık.

```{r}
preProcessParams <- preProcess(iris[,1:4], method=c("scale")) #Herbir gözlemi standart sapmaya oranladık. 
print(preProcessParams)
```

$$
\frac{x_(i)}{\sigma_(x)}
$$
İşlemleri belirli veri kümelerine uygulamak için `predict` komutunu kullandık.

```{r}
scaled <- predict(preProcessParams, iris[,1:4]) #predict fonksiyonunu dönüştürerek iris 1:4 e yazdırdık.
summary(scaled)
```

`preProcess` altındaki `scale` paketini çağırdık ve dönüşüm yaparak yazdırdık.

```{r}
preProcessParams <- preProcess(iris[,1:4], method=c("center")) #xi-xmü yaptık
print(preProcessParams)

centered <-  predict(preProcessParams, iris[,1:4])
summary(centered)
```

$$
x_{i}-\bar{X}_{x}
$$
Standardizasyon uygulayabilmek için;

```{r}
preProcessParams <- preProcess(iris[,1:4], method=c("center", "scale"))
print(preProcessParams)

standardized <- predict(preProcessParams, iris[,1:4])
summary(standardized)
```

$$
\frac{x_{i}-\mu{x}}{\sigma_{x}}
$$

Normalizasyon uygulayabilmek için;

```{r}
preProcessParams <- preProcess(iris[,1:4], method=c("range")) 
print(preProcessParams)

normalized <- predict(preProcessParams, iris[,1:4])
summary(normalized)
```

$$
\frac{x-min\left(x \right )}{max\left(x \right )-min\left(x \right )}
$$
`boxcox` dönüşümü, normal olarak dağıtılmamış bir veri kümesini daha normal dağılmış bir veri kümesine dönüştürmek için yaygın olarak kullanılan bir yöntemdir. `boxcox` uygulayabilmek için;

```{r}
preProcessParams <- preProcess(iris[,1:4], method=c("BoxCox"))
print(preProcessParams)

boxcox <- predict(preProcessParams, iris[,1:4])
summary(boxcox)
```

$$
y\left( \lambda \right )=\left\{\begin{matrix}\frac{y^ \lambda -1 }{\lambda}, & if \lambda\neq 0\\ log\left (y  \right ), & if \lambda = 0 \end{matrix}\right.
$$

`Yeo-Johnson` dönüşümü, normalleştirme dönüşümünü hesaplar. `yeojohnson` uygulabilmek için;

```{r}
preProcessParams <- preProcess(iris[,1:4], method=c("YeoJohnson"))
print(preProcessParams)

yeojohnson <- predict(preProcessParams, iris[,1:4])
summary(yeojohnson)
```

$$
\psi \left( \lambda, y \right )=

\left\{\begin{matrix}

({(\lambda +1)^\lambda -1)/\lambda}, & if \lambda\neq 0, y\geq 0\\

log\left (y+1  \right ), & if \lambda = 0, y\geq 0 \\ 

-[(-y+1)^{2-\lambda }-1)]/(2-\lambda), & if \lambda \neq  2, y< 0 \\ 

-log\left (-y+1  \right ), & if \lambda = 2, y< 0\end{matrix}\right.
$$

Teniden örnekleme yöntemi için ilk olarak veri setimiz geri çağırdık. Bunun için;

```{r}
data(iris)
summary(dataset)
dataset <- iris
```

Bootstrap ile 100 örneklem oluşturduk. Bu örneklemin oluşturulması için  yapılması gereken işlemler;

```{r}
train_control <- trainControl(method="boot", number=100)
```

Verisetinin %80'ini ayıran komut işlemi için;

```{r}
split=0.80
trainIndex <- createDataPartition(iris$Species, p=split, list=FALSE)
data_train <- iris[ trainIndex, ]
data_test <- iris[ -trainIndex, ]
```

Leave One Out Cross Validation yöntemiyle örnekleme yapmak için ilk caret package'ı aktif ettik. Sonrasında örneklem yönteminin komutu yazdık. Bu adımlar aşağıdaki gibi gösterilebilir.

```{r}
Library(caret)
data(iris)
train_control <-trainControl(method="LOOCV")
```

K-Fold Cross Validation için aşağıdaki adımları yürüttük;

```{r}
data(iris)
train_control <- trainControl(method="cv", number=10)
```

Son olarak Repeated Cross Validations yöntemini uygulamak içinse aşağıdaki adımları uyguladıkİ

```{r}
data(iris)
train_control <- trainControl (method="repeatedcv", number=10, repeats=3)
```

`cars` paketinin ilk altı (6) satırını, yapısını ve özetine baktık.

```{r}
head(cars)
str(cars)
summary(cars)
```

Daha sonra değişkenleri isimleri ile çağıracağımızdan dolayı `names()` fonksiyonunu kullandık.

```{r}
names(cars)
```

Verisetinin regresyon modeli uygun olup olmadığını ile eğrisel mi yoksa doğrusal mı olduğunu `scatter.smooth()` kodu ile gösterdik.

```{r}
scatter.smooth(x=cars$speed, y=cars$dist, main="Saçılma Diyagramı")
```

Korelasyon üretmek için `cor()` kodunu kullandık.

```{r}
cor(cars$speed, cars$dist)
```

Regresyon modelini oluşturmak için `lm()` fonksiyonunu kullandık ve bunu 'GenelModel'e atadık.

```{r}
GenelModel <- lm(dist ~ speed, data=cars) # lm(bağımlı ve bağımsız değişken) (lm, bağımlı değişken, bağımsız değişken , veriseti)
```

GenelModel içerisindeki tahmini 'distance'ı almak için `print()` ve daha sonra GenelModel'in özetini görmek için `summary()` komutunu kullandık.

```{r}
print(GenelModel)
summary(GenelModel)
```

Bilgi kriterlerini bulabilmek için `AIC()` ve `BIC()` komutlarını kullandık.

```{r}
AIC(GenelModel) 
BIC(GenelModel)
```

Rassal değerleri bulabilmek için `set.seed()` fonksiyonundan yararlandık.

```{r}
set.seed(100)
```

Satır index değerlerini `sample()` fonksiyonu ile oluşturduk ve değerleri 'trainingRowIndex'e atadık.

```{r}
trainingRowIndex <- sample(1:nrow(cars), 0.8*nrow(cars)) # 1'den n row'a kadar verinin yüzde 80'ini rassal olarak seçtik.
```

cars verisetindeki daha önce oluşturduğumuz trainingRowIndex satırını ve tüm sütununu 'trainingData'ya atadık.

```{r}
trainingData <- cars[trainingRowIndex, ] #satırlarını al ve tüm sütunlarını al
```

'testData'ya 'trainingRowIndex'in tersini atadık.

```{r}
testData <- cars[-trainingRowIndex, ]
```

Tekrar Regresyon modelini oluşturmak için `lm()` fonksiyonunu kullandık ve bunu 'lmMod'a atadık. Daha sonra testData'sının tahmini değerlerini `predict()` komutu ile aldık ve `print()` `summary()` ile `ÀIC()` komutları ile verisinin içerisine baktık.

```{r}
lmMod <- lm(dist ~ speed, data=trainingData)
distPred <- predict(lmMod, testData) 
print(distPred)
summary(lmMod)
AIC(lmMod)
```

Gözlemlediğimiz ve tahmin ettiğimiz verileri birleştiriyor (bind). Yani iki vektörü birleştiriyor (bind) ve yeni bir vektör oluşturuyor. Bunun için `data.frame()` fonksiyonundan yararlandık. Ve yeni bulduğumuz vektörü 'actuals_preds'e atadık.

```{r}
actuals_preds <- data.frame(cbind(gercek=testData$dist, tahmin=distPred)) 
```

Yeni oluşturduğumuz verimizin korelasyonuna `cor()` fonksiyonu ile bakıyoruz ve bunu 'correlation_accuracy'e atadık.Daha sonra verimizin ilk altı (6) satırına baktık.

```{r}
correlation_accuracy <- cor(actuals_preds)
head(actuals_preds)
```

mape (min personch error) yani gerçek değer ie tahmini değer arasındaki farkın mutlak değerini alarak gerçek değere oranlıyoruz. Diğer bir deyişle hata payını alarak gerçek değere oranlıyoruz. Ve `print()` komutu ile çıktısını alıyoruz.

```{r}
mape <- mean(abs(actuals_preds$tahmin - actuals_preds$gercek)/actuals_preds$gercek)
print(mape)
```






